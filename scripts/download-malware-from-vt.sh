#!/bin/bash

# Input:
# File with list Virus Total Malware Hashes (One Per line)
# Base Download Folder (default : /data/malware)

# Logic:
# 1. Create a working copy of the malwares hash containing file if not present. ${CURRENT_FILE_NAME}.work
# 2. Read the first file from ${CURRENT_FILE_NAME}.work. If line empty, stop.
# 3. Check if malware was downloaded in path ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/${MALWARE_HASH}
# 4. If the malware exists, go to step 8.
# 5. If the malware does not exist, try to download ${MALWARE_HASH} from Virus Total and save to file ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/${MALWARE_HASH}.
# 6. If the download was successful, go to step 8.
# 7. If the download fails, check failure cause. 
#     i. If the failure is due to download limit, stop the entire download process.
#     ii. Any other failure cause go to step 9. 
# 8. Append the ${MALWARE_HASH} to ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/download.successful and remove ${MALWARE_HASH} from ${CURRENT_FILE_NAME}, go to step 10
# 9. Append the ${MALWARE_HASH} to ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/download.failure and remove ${MALWARE_HASH} from ${CURRENT_FILE_NAME}, go to step 10
# 10. Remove first line from ${CURRENT_FILE_NAME}.work, go to step 2.

function usage()
{
    echo -n "
    Download potential malware from VirusTotal 

    Usage:
      ./download-malware-from-vt.sh --malwares-hash-file <MALWARES_HASH_FILE> [--base-download-folder <BASE_DOWNLOAD_FOLDER>]

    Options:
        --help                                          Show this screen
        --malwares-hash-file <MALWARES_HASH_FILE>       The file containing the hashs of the potential malware
        --base-download-folder <BASE_DOWNLOAD_FOLDER>   [optional] The base folder to save downloaded malware.
                                                        Defaults to /data/malwares.    
    "
    echo
}

function parse_args()
{
    if [[ "$#" -eq 0 ]]; then
        usage
        exit 1
    fi

    while (( "$#" )); do
        case "$1" in
            --malwares-hash-file)
            MALWARES_HASH_FILE="$2"
            shift 2
            ;;
      			--base-download-folder)
            BASE_DOWNLOAD_FOLDER="$2"
            shift 2
            ;;
            --help)
            usage
            exit 0
            ;;
            --) # end argument parsing
            shift
            break
            ;;
            -*|--*) # unsupported flags
            echo "Error: Unsupported flag $1" >&2
            exit 1
            ;;
            *) # preserve positional arguments
            PARAMS="$PARAMS $1"
            shift
            ;;
        esac
    done
}

function validate()
{
    if [[ -z ${MALWARES_HASH_FILE} ]];
    then
        usage
        exit 0
    fi
}

parse_args "$@"
validate

DEFAULT_BASE_DOWNLOAD_FOLDER="/data/malwares"
BASE_DOWNLOAD_FOLDER=${BASE_DOWNLOAD_FOLDER:-$DEFAULT_BASE_DOWNLOAD_FOLDER}

MALWARES_HASH_FILE_NAME=$(basename ${MALWARES_HASH_FILE})
MALWARES_HASH_FILE_FULL_PATH=$(readlink -f ${MALWARES_HASH_FILE})
MALWARES_HASH_FILE_WORKING_COPY=${MALWARES_HASH_FILE_FULL_PATH}.work
if [ ! -f ${MALWARES_HASH_FILE_WORKING_COPY} ]; then
  cp ${MALWARES_HASH_FILE} ${MALWARES_HASH_FILE_WORKING_COPY} 
fi
SCRIPT_FOLDER=$(dirname $(readlink -f "$0"))
source ${SCRIPT_FOLDER}/secrets.env
mkdir -p ${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}
exec 1>>${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}/download.log 2>&1

function log(){
  echo "[$(date +%FT%T)] - $1"
}

function download_malware(){
  local __NAME=$(basename $1)
  log "Downloading $__NAME from Virus Total"
  local __RESPONSE_CODE=$(curl --silent --request GET -L \
        --url https://www.virustotal.com/api/v3/files/${__NAME}/download \
        --header "x-apikey: ${PREMIUM_VT_API_KEY}" \
        --output $1 --write-out %{http_code})
  local __RESPONSE="Success"
  if (( 400 <= ${__RESPONSE_CODE} )); then
    __RESPONSE="Failure"
    local __RESPONSE_ERROR=$(cat $1 | jq -c '.error')
    local __RESPONSE_ERROR_CODE=$(echo $__RESPONSE_ERROR | jq -r '.code')
    if (( ${__RESPONSE_CODE} == 429 )); then
      __RESPONSE=${__RESPONSE_ERROR_CODE}
    fi
    log "Download of ${__NAME} failed due to $__RESPONSE_ERROR"
    rm $1
  else
    log "Download of ${__NAME} was successful"
  fi
  
  if [[ -n $2 ]]; then
    local __RESULTVAR=$2
    eval $__RESULTVAR="'$__RESPONSE'"
  fi
}

log "$(seq 40 | sed 's/.*/*/' | tr -d '\n') START $(seq 40 | sed 's/.*/*/' | tr -d '\n')"
while [ true ];
do
  MALWARE_HASH=$(head -n 1 ${MALWARES_HASH_FILE_WORKING_COPY})
  if [ -z ${MALWARE_HASH} ]; then
    log "Exiting due to: Reached end of work file"
    break
  fi
  
  if [ -f "${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}/${MALWARE_HASH}" ]; then
    log "${MALWARE_HASH} already downloaded"
  else
    download_malware ${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}/${MALWARE_HASH} RESPONSE
    case "${RESPONSE}" in
      QuotaExceededError | TooManyRequestsError)
      log "Exiting due to: Reached Max Quota"
      break
      ;;
      Failure)
      echo ${MALWARE_HASH} >> ${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}/download.failure
      ;;
      Success)
      echo ${MALWARE_HASH} >> ${BASE_DOWNLOAD_FOLDER}/${MALWARES_HASH_FILE_NAME}/download.successful
      ;;
    esac
  fi
  sed -i 1d ${MALWARES_HASH_FILE_WORKING_COPY}
done
log "$(seq 41 | sed 's/.*/*/' | tr -d '\n') END $(seq 41 | sed 's/.*/*/' | tr -d '\n')"
echo