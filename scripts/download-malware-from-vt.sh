#!/bin/bash

# Input:
# File with list Virus Total Malware Hashes (One Per line)
# Base Download Folder (default : /data/malware)

# Logic:
# 1. Create a working copy of the malwares hash containing file if not present. ${CURRENT_FILE_NAME}.work
# 2. Read the first file from ${CURRENT_FILE_NAME}.work. If line empty, stop.
# 3. Check if malware was downloaded in path ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/${MALWARE_HASH}
# 4. If the malware exists, go to step 8.
# 5. If the malware does not exist, try to download ${MALWARE_HASH} from Virus Total and save to file ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/${MALWARE_HASH}.
# 6. If the download was successful, go to step 8.
# 7. If the download fails, check failure cause. 
#     i. If the failure is due to download limit, stop the entire download process.
#     ii. Any other failure cause go to step 9. 
# 8. Append the ${MALWARE_HASH} to ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/download.successful and remove ${MALWARE_HASH} from ${CURRENT_FILE_NAME}, go to step 10
# 9. Append the ${MALWARE_HASH} to ${BASE_DOWNLOAD_FOLDER}/${CURRENT_FILE_NAME}/download.failure and remove ${MALWARE_HASH} from ${CURRENT_FILE_NAME}, go to step 10
# 10. Remove first line from ${CURRENT_FILE_NAME}.work, go to step 2.

function usage()
{
    echo -n "
    Download potential malware from VirusTotal 

    Usage:
      ./download-malware-from-vt.sh --malwares-hash-file <MALWARES_HASH_FILE> [--base-download-folder <BASE_DOWNLOAD_FOLDER>]

    Options:
        --help                                                              Show this screen
        --malwares-hash-file <MALWARES_HASH_FILE>                           The file containing the hashs of the potential malware
        --base-download-folder <BASE_DOWNLOAD_FOLDER>                       [optional] The base folder to save downloaded malware.
                                                                            Defaults to ${DEFAULT_BASE_DOWNLOAD_FOLDER}
        --malware-download-relative-path <MALWARE_DOWNLOAD_RELATIVE_PATH>   [optional]
                                                                            Defaults to empty string
        --download-budget <DOWNLOAD_BUDGET>                                 [optional] The max allowed downloads
    "
    echo
}

function parse_args()
{
    if [[ "$#" -eq 0 ]]; then
        usage
        exit 1
    fi

    while (( "$#" )); do
        case "$1" in
            --malwares-hash-file)
            MALWARES_HASH_FILE="$2"
            shift 2
            ;;
      			--base-download-folder)
            BASE_DOWNLOAD_FOLDER="$2"
            shift 2
            ;;
            --malware-download-relative-path)
            MALWARE_DOWNLOAD_RELATIVE_PATH="$2"
            shift 2
            ;;
            --download-budget)
            DOWNLOAD_BUDGET="$2"
            shift 2
            ;;
            --help)
            usage
            exit 0
            ;;
            --) # end argument parsing
            shift
            break
            ;;
            -*|--*) # unsupported flags
            echo "Error: Unsupported flag $1" >&2
            exit 1
            ;;
            *) # preserve positional arguments
            PARAMS="$PARAMS $1"
            shift
            ;;
        esac
    done
}

function validate()
{
    if [[ -z ${MALWARES_HASH_FILE} ]];
    then
        usage
        exit 0
    fi
}

function log(){
  echo "[$(date +%FT%T)] - $1"
}

function download_malware(){
  local __NAME=$(basename $1)
  log "Downloading $__NAME from Virus Total"
  __RESPONSE_CODE=$(curl --request GET \
                        --location \
                        --silent \
                        --url https://www.virustotal.com/api/v3/files/${__NAME}/download \
                        --header "x-apikey: ${PREMIUM_VT_API_KEY}" \
                        --output $1 \
                        --show-error \
                        --write-out %{http_code})
  local __CURL_EXIT_CODE=$?
  local __RESPONSE="Failure"
  if [[ "$__CURL_EXIT_CODE" -eq 0 ]]; then
    if (( 400 <= ${__RESPONSE_CODE} )); then
      local __RESPONSE_ERROR=$(cat $1 | jq -c '.error')
      local __RESPONSE_ERROR_CODE=$(echo $__RESPONSE_ERROR | jq -r '.code')
      if (( ${__RESPONSE_CODE} == 429 )); then
        __RESPONSE=${__RESPONSE_ERROR_CODE}
      fi
      log "Download of ${__NAME} failed due to $__RESPONSE_ERROR"
      rm $1
    else
      __RESPONSE="Success"
      log "Download of ${__NAME} was successful"
    fi
  else
      log "Download of ${__NAME} failed"
  fi
  
  if [[ -n $2 ]]; then
    local __RESULTVAR=$2
    eval $__RESULTVAR="'$__RESPONSE'"
  fi
}

function main() 
{
  SCRIPT_FOLDER=$(dirname $(readlink -f "$0"))
  source ${SCRIPT_FOLDER}/utils.sh

  parse_args "$@"
  
  validate

  source ${SCRIPT_FOLDER}/secrets.env

  BASE_DOWNLOAD_FOLDER=${BASE_DOWNLOAD_FOLDER:-$DEFAULT_BASE_DOWNLOAD_FOLDER}
  MALWARE_DOWNLOAD_RELATIVE_PATH=${MALWARE_DOWNLOAD_RELATIVE_PATH:-$DEFAULT_MALWARE_DOWNLOAD_SUFFIX_PATH}

  MALWARES_HASH_FILE_NAME=$(basename ${MALWARES_HASH_FILE})
  MALWARES_HASH_FILE_NAME_WORKING_COPY=${MALWARES_HASH_FILE_NAME}.download.remain

  MALWARES_HASH_FILE_DOWNLOAD_FOLDER=${BASE_DOWNLOAD_FOLDER}/${MALWARE_DOWNLOAD_RELATIVE_PATH}/${MALWARES_HASH_FILE_NAME}
  MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER="$(dirname $(readlink -f ${MALWARES_HASH_FILE}))/${DEFAULT_MALWARE_DONWLOAD_STATUS_RELATIVE_PATH}"

  create_directory ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}
  create_directory ${MALWARES_HASH_FILE_DOWNLOAD_FOLDER}

  if [ ! -f ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME_WORKING_COPY} ]; then
    cp ${MALWARES_HASH_FILE} ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME_WORKING_COPY} 
  fi

  exec 6>&1
  exec >>${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME}.download.log 2>&1

  REACHED_DAILY_QUOTA=false
  SUCCESSFUL_DOWNLOADS=0

  log "$(seq 40 | sed 's/.*/*/' | tr -d '\n') START $(seq 40 | sed 's/.*/*/' | tr -d '\n')"
  while [ true ];
  do
    MALWARE_HASH=$(head -n 1 ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME_WORKING_COPY})
    if [ -z ${MALWARE_HASH} ]; then
      log "Exiting due to: Reached end of work file"
      break
    fi
    
    if [ -f "${MALWARES_HASH_FILE_DOWNLOAD_FOLDER}/${MALWARE_HASH}" ]; then
      log "${MALWARE_HASH} already downloaded"
    else
      download_malware ${MALWARES_HASH_FILE_DOWNLOAD_FOLDER}/${MALWARE_HASH} RESPONSE
      case "${RESPONSE}" in
        QuotaExceededError | TooManyRequestsError)
        log "Exiting due to: Reached Max Quota"
        REACHED_DAILY_QUOTA=true
        break
        ;;
        Failure)
        echo ${MALWARE_HASH} >> ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME}.download.failure
        ;;
        Success)
        SUCCESSFUL_DOWNLOADS=$(( $SUCCESSFUL_DOWNLOADS + 1 ))
        echo ${MALWARE_HASH} >> ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME}.download.successful
        ;;
      esac
    fi
    sed -i 1d ${MALWARES_HASH_FILE_DOWNLOAD_STATUS_FOLDER}/${MALWARES_HASH_FILE_NAME_WORKING_COPY}
    if [[ -n $DOWNLOAD_BUDGET && $SUCCESSFUL_DOWNLOADS -eq $DOWNLOAD_BUDGET ]]
    then
      log "Reached allowed download limit"
      break
    fi
  done
  log "$(seq 41 | sed 's/.*/*/' | tr -d '\n') END $(seq 41 | sed 's/.*/*/' | tr -d '\n')"
  echo

  exec 1>&6 6>&-
  echo "{ \"reached_daily_quota\": ${REACHED_DAILY_QUOTA}, \"successful_downloads\": ${SUCCESSFUL_DOWNLOADS} }"
}

main "$@"